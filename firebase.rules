rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthenticated() { return request.auth != null }
    function isParent() { return isAuthenticated() && request.auth.token.role == 'parent' }
    function isParentOwner(uid) { return isParent() && request.auth.uid == uid }
    function hasShareAccess(parentId, childId) {
      return request.auth != null && ('share' in request.auth.token) &&
        request.auth.token.share.parentId == parentId &&
        request.auth.token.share.childId == childId
    }
    function isAnonymous() {
      return isAuthenticated() && request.auth.token.firebase != null && request.auth.token.firebase.sign_in_provider == 'anonymous'
    }
    // Parent owns family when their uid matches fid or they're listed in parentUIDs
    function parentOwnsFamily(fid) {
      return isParent() && (
        request.auth.uid == fid || (
          exists(/databases/$(database)/documents/families/$(fid)) &&
          (request.auth.uid in get(/databases/$(database)/documents/families/$(fid)).data.parentUIDs)
        )
      )
    }
    // Families root doc: parents can read/write their family, but cannot change parentUIDs or familyCode via client
    match /families/{fid} {
      allow read: if parentOwnsFamily(fid);
      allow create, update: if parentOwnsFamily(fid) &&
        (
          // parentUIDs/familyCode must be unchanged when present
          (!('parentUIDs' in request.resource.data) || (('parentUIDs' in resource.data) && request.resource.data.parentUIDs == resource.data.parentUIDs)) &&
          (!('familyCode' in request.resource.data) || (('familyCode' in resource.data) && request.resource.data.familyCode == resource.data.familyCode))
        );
      allow delete: if false; // server-only

      // Common subcollections under families
      match /childSessions/{uid} {
        // Session owner can read their session; writes are server-side (Admin SDK)
        allow read: if isAuthenticated() && request.auth.uid == uid;
        allow write: if false;
      }

      // Other subcollections (e.g., settings, audit, parentData) are parent-only
      match /{sub=**} {
        allow read, write: if parentOwnsFamily(fid);
      }
    }

    // Users collection
    match /users/{parentId} {
      // Parents can read and manage their own profile document, but never escalate role via client writes
      allow read: if isParentOwner(parentId);
      allow create: if isParentOwner(parentId) && ('role' in request.resource.data) && request.resource.data.role == 'parent';
      allow update: if isParentOwner(parentId) &&
        (!('role' in request.resource.data) || request.resource.data.role == resource.data.role) &&
        (!('familyId' in request.resource.data) || request.resource.data.familyId == resource.data.familyId) &&
        (!('childId' in request.resource.data) || request.resource.data.childId == resource.data.childId);
      allow delete: if false;

      // Children subcollection is parent-only for reads and writes
      match /children/{childId} {
        allow read, write: if isParentOwner(parentId);

        // Gifts are readable by the parent, or a caller presenting a share claim, and writable by the parent only
        match /gifts/{giftId} {
          allow read: if isParentOwner(parentId) || hasShareAccess(parentId, childId);
          allow create, update, delete: if isParentOwner(parentId);
        }

        // Any other child-nested collections remain parent-only
        match /{sub=**} {
          allow read, write: if isParentOwner(parentId);
        }
      }
    }

    // Share tokens are controlled by the parent; optional share claims can read the token document for verification
    match /shareTokens/{shareId} {
      allow create: if isParent() && request.auth.uid == request.resource.data.parentId;
      allow read: if (isParent() && request.auth.uid == resource.data.parentId) ||
        hasShareAccess(resource.data.parentId, resource.data.childId);
      allow update, delete: if isParent() && request.auth.uid == resource.data.parentId;
    }

    // Anonymous workspace: only anonymous users can access their own space
    match /anon_workspaces/{anonUid}/{sub=**} {
      allow read, write: if isAnonymous() && isAuthenticated() && request.auth.uid == anonUid;
    }
  }
}
