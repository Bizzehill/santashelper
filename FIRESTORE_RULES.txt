rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isParentOwner(userId) { return request.auth != null && request.auth.token.role == 'parent' && request.auth.uid == userId }
    function hasChildSession(userId) { return request.auth != null && exists(/databases/$(database)/documents/families/$(userId)/childSessions/$(request.auth.uid)) && get(/databases/$(database)/documents/families/$(userId)/childSessions/$(request.auth.uid)).data.expireAt > request.time }
    function allowedChild(userId, childId) { return hasChildSession(userId) && get(/databases/$(database)/documents/families/$(userId)/childSessions/$(request.auth.uid)).data.allowedChildId == childId }
    // Families collection: parent-only access to sensitive areas
    match /families/{familyId} {
      // Settings doc: only the owning parent can read/write. Prevent changing parentPinHash once set.
      match /settings {
        function isParent() { return request.auth != null && request.auth.token.role == 'parent' }
        function isOwner() { return request.auth != null && request.auth.uid == familyId }
        // Allow read for owning parent
        allow read: if isParent() && isOwner();
        // Allow write for owning parent, but do not allow modifying parentPinHash if it already exists
        allow write: if isParent() && isOwner() && (
          // First-time set (no parentPinHash on existing doc)
          !("parentPinHash" in resource.data) ||
          // Or updates that do not touch the parentPinHash field
          !("parentPinHash" in request.resource.data)
        );
      }
      // Any docs under parentData: parent-only read/write
      match /parentData/{document=**} {
        allow read, write: if request.auth != null && request.auth.token.role == 'parent';
      }

      // Audit collection: write-only for parents (read can be restricted or enabled for parents as needed)
      match /audit/{docId} {
        allow write: if request.auth != null && request.auth.token.role == 'parent';
        // Optional: allow parents to read their own audit trail
        allow read: if request.auth != null && request.auth.token.role == 'parent';
      }

      // Child sessions: allow the session owner to read their own doc (server writes with Admin SDK bypass rules)
      match /childSessions/{uid} {
        allow read: if request.auth != null && request.auth.uid == uid;
      }
    }

    match /users/{userId} {
      // Allow read to owning parent, or any user with a valid child session for this family
      allow read: if isParentOwner(userId) || hasChildSession(userId);
      // Only owning parent can write root doc; prevent clients from writing role field
      allow write: if isParentOwner(userId) && !('role' in request.resource.data);

      // Allow server to mirror role into user doc when caller is admin (via custom claim)
      allow update: if request.auth != null && request.auth.token.admin == true;

      match /children/{childId} {
        // Read allowed to owning parent, or a user with a valid child session for this child
        allow read: if isParentOwner(userId) || allowedChild(userId, childId);
        // Only owning parent can write child documents by default
        allow write: if isParentOwner(userId);

        // Wishlist: parent-only writes
        match /wishlist/{docId} {
          allow read: if isParentOwner(userId) || allowedChild(userId, childId);
          allow write: if isParentOwner(userId);
        }

        // Deeds: allow child to create entries; parent controls updates/deletes
        match /deeds/{docId} {
          allow read: if isParentOwner(userId) || allowedChild(userId, childId);
          // Allow child to create deeds for their own child session
          allow create: if isParentOwner(userId) || allowedChild(userId, childId);
          // Updates/deletes reserved for parent owner
          allow update, delete: if isParentOwner(userId);
        }

        // Fallback for other nested collections: parent-only writes
        match /{sub=**} {
          allow read: if isParentOwner(userId);
          allow write: if isParentOwner(userId);
        }
      }
    }
  }
}
